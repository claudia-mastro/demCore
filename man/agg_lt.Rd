% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agg_lt.R
\name{agg_lt}
\alias{agg_lt}
\title{Aggregate life table(s) to less granular age groups}
\usage{
agg_lt(
  dt,
  id_cols,
  age_mapping,
  missing_dt_severity = "stop",
  drop_present_aggs = F
)
}
\arguments{
\item{dt}{[\code{data.table()}]\cr
Life table  to be aggregated. Must include all columns in \code{id_cols}, and
at least two of 'qx', 'ax', and 'mx'.}

\item{id_cols}{[\code{character()}]\cr
ID columns that uniquely identify each row of \code{dt}.}

\item{age_mapping}{[\code{data.table()}]\cr
Specification of intervals to aggregate to. Required columns are
'age_start' and 'age_end'. Use "Inf" as 'age_end' for terminal age group.
The age group intervals must be contiguous and cover the entire interval
specified in the input life tables \code{dt}.}

\item{missing_dt_severity}{[\code{character(1)}]\cr
How severe should the consequences of missing data that prevents
aggregation or scaling from occurring be? Can be either 'stop', 'warning',
'message', or 'none'. If not "stop", then only the possible aggregations or
scaling is done using the available data.}

\item{drop_present_aggs}{[\code{logical(1)}]\cr
Whether to drop aggregates (or overlapping intervals) that are already
present in \code{dt} before aggregating. Default is 'False' and the function
errors out.}
}
\value{
[\code{data.table()}]\cr Aggregated life table(s) with columns for
\code{id_cols}, 'qx', and 'ax'. Will only include the age groups specified in
\code{age_mapping}.
}
\description{
Aggregate life table(s) to less granular age groups using
standard life table aggregation functions.
}
\examples{
dt <- data.table::data.table(
  age_start = c(0:110),
  age_end = c(1:110, Inf),
  location = "Canada",
  qx = .2,
  ax = .5
)
id_cols = c("age_start", "age_end", "location")
dt <- agg_lt(
  dt = dt,
  id_cols = id_cols,
  age_mapping = data.table::data.table(
    age_start = seq(0, 110, 5),
    age_end = c(seq(5, 110, 5), Inf)
  )
)
}
\seealso{
hierarchyUtils::agg
}
