% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agg_qx.R
\name{agg_qx}
\alias{agg_qx}
\title{Aggregate qx values over age}
\usage{
agg_qx(dt, id_cols, age_mapping, drop_present_aggs = F)
}
\arguments{
\item{dt}{[\code{data.table()}]\cr Data to be aggregated.
\itemize{
\item Must only include columns 'qx' and those specified in \code{id_cols}
\item Must include 'age_start' and 'age_end' columns
}}

\item{id_cols}{[\code{character()}]\cr
ID columns that uniquely identify each row of \code{dt}.}

\item{age_mapping}{[\code{data.table()}]\cr Specification of intervals to
aggregate to. Required columns are 'age_start' and 'age_end'. Use "Inf" as
'age_end' for terminal age group.}

\item{drop_present_aggs}{[\code{logical(1)}]\cr
Whether to drop aggregates (or overlapping intervals) that are already
present in \code{dt} before aggregating. Default is 'False' and the function
errors out.}
}
\value{
[\code{data.table()}]\cr Aggregated qx values, has \code{id_cols} and 'qx'
columns for aggregate age groups.
}
\description{
Given a data.table with a qx variable and ID variables that
uniquely identify the data, compile granular ages and aggregate into
combined qx values. Using probability rules, we convert qx to px
(conditional survival probability), multiply these px values within a
specified age range together to get the conditional probability of survival
through all granular age groups, and subtract from one to get the
aggregated conditional probability of death (qx).
}
\details{
This function is a wrapper for \code{\link[demUtils:agg]{demUtils::agg()}}.
}
\examples{
dt <- data.table::data.table(
  id = c(rep(1, 5), rep(2, 5)),
  qx = c(rep(.1, 5), rep(.2, 5)),
  age_start = rep(seq(15, 35, 5), 2),
  age_end = rep(seq(20, 40, 5), 2)
)
age_mapping <- data.table::data.table(age_start = c(15), age_end = c(40))
agg_qx(dt, id_cols = c("id", "age_start", "age_end"),
        age_mapping = age_mapping)
}
