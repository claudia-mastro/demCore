% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agg_qx.R
\name{agg_qx}
\alias{agg_qx}
\title{Aggregate qx values over age}
\usage{
agg_qx(dt, id_cols, target_ages_dt)
}
\arguments{
\item{dt}{data.table with data to be aggregated.
\itemize{
\item must only include columns 'qx' and those specified in \code{id_cols}
\item must include 'age_start' and 'age_end' columns
\item \code{id_cols} must uniquely identify each row
}}

\item{id_cols}{character vector of column names that uniquely identify each row
of \code{dt}}

\item{target_ages_dt}{data.table defining age groups to aggregate to.
\itemize{
\item must include 'age_start' and 'age_end' columns.
}}
}
\value{
data.table with \code{id_cols} and \code{qx} columns for aggregate age groups.
}
\description{
Given a data.table with a qx variable and ID variables that uniquely
identify the data, compile granular ages and aggregate into combined qx values.
Using probability rules, we convert qx to px (conditional survival probability),
multiply these px values within a specified age range together to get the
conditional probability of survival through all granular age groups, and
subtract from one to get the aggregated conditional probability of death (qx).
}
\details{
this function is a wrapper for demUtils::aggregate_age
}
\examples{
dt <- data.table::data.table(
  id = c(rep(1, 5), rep(2, 5)), qx = c(rep(.1, 5), rep(.2, 5)),
  age_start = rep(seq(15, 35, 5), 2),
  age_end = rep(seq(20, 40, 5), 2)
)
target_dt <- data.table::data.table(age_start = c(15),
                                    age_end = c(40))
agg_qx(dt, id_cols = c("id", "age_start", "age_end"), target_ages_dt = target_dt)

}
