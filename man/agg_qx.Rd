% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agg_qx.R
\name{agg_qx}
\alias{agg_qx}
\title{Aggregate qx values over age}
\usage{
agg_qx(dt, id_cols, age_mapping, drop_present_aggs = F)
}
\arguments{
\item{dt}{[\code{data.table()}] data to be aggregated.
\itemize{
\item must only include columns 'qx' and those specified in \code{id_cols}
\item must include 'age_start' and 'age_end' columns
\item \code{id_cols} must uniquely identify each row
}}

\item{id_cols}{character vector of column names that uniquely identify each
row of \code{dt}}

\item{age_mapping}{[\code{data.table()}] specification of intervals to aggregate
to. Required columns are 'age_start' and 'age_end'. Use "Inf" as 'age_end'
for terminal age group.}

\item{drop_present_aggs}{[\code{logical()}] whether to drop aggregates (or
overlapping intervals) that are already present in dt before aggregating.
Default is "False" and the function errors out.}
}
\value{
data.table with \code{id_cols} and \code{qx} columns for aggregate age groups.
}
\description{
Given a data.table with a qx variable and ID variables that
uniquely identify the data, compile granular ages and aggregate into
combined qx values. Using probability rules, we convert qx to px
(conditional survival probability), multiply these px values within a
specified age range together to get the conditional probability of survival
through all granular age groups, and subtract from one to get the
aggregated conditional probability of death (qx).
}
\details{
This function is a wrapper for demUtils::aggregate_age
}
\examples{
dt <- data.table::data.table(
  id = c(rep(1, 5), rep(2, 5)),
  qx = c(rep(.1, 5), rep(.2, 5)),
  age_start = rep(seq(15, 35, 5), 2),
  age_end = rep(seq(20, 40, 5), 2)
)
age_mapping <- data.table::data.table(age_start = c(15), age_end = c(40))
agg_qx(dt, id_cols = c("id", "age_start", "age_end"),
        age_mapping = age_mapping)
}
